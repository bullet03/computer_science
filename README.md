# Computer Science

## СОДЕРЖАНИЕ
- Immer (#immer)

___________________________________________________________________________________________________
Shallow copy - поверхностное копирование, т.е. пересоздание с нуля только первого уровня объекта (вложенные объекты буду унаследованы по ссылке)

Structural sharing -
- возвращает независимую копию данных
- если в части исходной структуры данные НЕ поменялись, то их же и возвращаем (копируем по ссылке)
- если в части исходной структуры данные поменялись, то эти части пересоздаем с нуля с новыми значениями (пересоздаем через shallow copy)
- если в части исходной структуры данные поменялись ГЛУБОКО, то весь путь от этого глубокого изменения до корня на каждом уровне должен быть пересоздан через shallow copy (.../Object.assign)

В примере ниже мы хотим поменять m на 321. Это изменение вызовет shallow copy объекта под ключом k. Тогда для объекта y свойство k поменялось, а значит весь объект под ключом y тоже надо прогнать через shallow copy. Тоже самое для объекта x с измененным ключом y. И таким формируется путь изменений. y2 затронут при этом не будет, скопируется по ссылке

const x = {
    y: {
        k: {
            m: 123
        }
    },
    y2: ...
}

Structural cloning -  синоним deep copy. С недавних пор официальное api браузера structuredClone (клонирует многие вещи, но не все, не клонирует методы). Не путать с Structural sharing

Reflect 
- Определение встроенный объект js, содержащий набор методов-обёрток вокруг внутренних методов (стандартного ECMASCRIPT) объекта по спецификации, т.е. ([[Get]], [[Set]], [[Delete]], [[Construct]], ...)
- Стандартный объект ECMASCRIPT - объект, поведение которого жёстко определено стандартными алгоритмами спецификации
- [[Get]], [[Set]], [[Delete]], [[Construct]] - не просто слова в квадратных скобках, это название стандартных алгоритмов спецификации, которые выполняют определенную последовательность шагов при взаимодействии с объектом (например, удаление, получение свойств и т.д.)
- Объекты, у которых поведение не совпадает с этими стандартными алгоритмамиЮ называются экзотическими. Например, Array, потому что его поведение установки нового свойства затрагивает перерасчет специфического только ему свойства length

Proxy
- встроенный в js декоратор над объектом
- в параметрах принимает исходный объект и объект с настройками декоратора (ловушки/trap)
- Настройки декоратора также перехыватывают алгоритмы (стандартного ECMASCRIPT) поведения объекта. Мы, программисты, благодаря этому перехвату можем изменить поведение target (исходного объекта)
- из-за того что proxy действует не только в мире js, но и за его пределами (обращаясь к внутренним свойствами вроде [[Get]] и т.д.), то на чужой территории програмимсту надо вести себя в соответствии с чужими законами, в данном случае согласно спецификации ECMASCRIPT (например, перенаправление корректного this => proxy намертво связан с исходным объектом и это может приводить к проблемам при наследовании в прототипной цепи; возвращение булевого флага при set; правильной обработки ошибок; ...)
- Программист самостоятельно обрабатывает все вышеуказзаные случаи, либо полагается на Reflect, который берёт обработку на себя. Важно помнить о Reflect, который поможет программисту. Даже Reflect не может закрыть все corner cases, как например, внутренние слоты (например [[MapData]] это аналог внтуренних свойств объекта вроде [[Get]], ...) Map, Set, приватные поля классов и тогда программисту все же приходится самостоятельно обрабатывать эти случаи
- Revoke Proxy возможность разорвать связь между исходным объектом и proxy

Immer - библиотека, которая позволяет писать код в mutable стиле. Наружу отдаем immutable копию данных, используя под капотом structural sharing

Термины библиотек и Immer:
- Produce внешнее api, которое принимает 2 параметра: base и recipe, возвращает новую immutable копию данных
- Recipe колбек который имеет параметр draft и меняет его в мутирующем стиле
- Base исходные пользовательские данные (не обязательно объект, м.б. и примитивы, maps, ...)
- Copy => shallow copy base
- State объект, содержащий base + copy + метаинформация
- Draft это прокси над state

История развития immer
- Рассмотрим react. Так react вызывает перерендер через сопоставление ссылок, а не вложенной не структуры, то важно на каждое изменение возвращать новую копию данных даже если оно произошло очень глубоко (принцип иммутабельности). Immer идеально ложится на данную философию
- шаг 1 решения проблемы. Вместо работы с исходными данными ВСЕГДА создаём копию. DeepClone копия затратно по ресурсам, поэтому используем shallow copy
- шаг 2 решения проблемы. Shallow copy имеет недостатки в виде НЕ обработки вложенных структуру данных и возврата каждый раз новой копии, даже если данные не поменялись
- шаг 3 решения проблемы. Содание обёртку, именуемую state. Исходные данные - base, shallowCopy от base - copy. Обёртка также содержит любую доп. информацию для коректной работы state в виде meta. Недостаток третьего шага - пользователь вместо изначальной data работает со сложным api в виде state, лишний головняк
- шаг 4 решения проблемы. Прячем state за proxy. Снаружи человек обращается будто бы к data, а внутри всё реализуется через proxy, используя structural sharing
- шаг 5 решения проблемы. Любые вложенные объекты обрабатываются рекурсивно создавая для КАЖДОГО из них свой proxy над своим state. Чтобы вернуть пользователю не систему state, а нормальный имутабельный объект, необходимо пробежаться по всем этим state и собрать новый имутабельный объект
- в процессе работы может образоваться микс base, copy, state. Чтобы избежать ситуации, когда снаружи у нас обычный base, а внутри изменен глубоко вложенный state, нам необходимо всю цепочку объектов, включая внешний base пересоздать (это философия structural sharing). Для этого флаг загрязнение глубоковложенного state распространяется на весь путь до верхнего base
- ![immer_history](/img/immer.png)

- produce внутри себя выполняет следующие действия:
  - scope = getCurrentScope() // singletone на весь вызов одного produce
  - draft = createProxy(base)
  - result = recipe(draft)
  - processResult(result, scope) // нормализация финального объекта для пользователя
- scope содержит:
  - drafts_  (собрание всех draft данного produce)
  - immer_   (экземпляр immer от имени которого вызван produce, часто используется вместо this во внутренней логике)
  - parent_  (родительский scope, produce можно вызывать внутри produce)
  - canAutoFreeze (все возвращаемые копии объекта можно замораживать)
  - unFinalizedDraft (количество незавершенных dratfs. Завершенный draft - м.б. это draft который в функции processResult был обработан)
- state содержит:
  - base
  - copy
  - proxy
  - revoke
  - parent (родительский proxy, не путать с родителььским scope)
  - scope
  - isModified
  - isFinalized
- latest служебная функция, которая возвращет либо copy, либо base из state
- peek(obj, prop) выдает актуальное значение по переданному ключу: 
  - если obj === draft, то latest(draft)[prop]
  - если не draft, то obj[prop]

________________________________________________________________________________________________________

